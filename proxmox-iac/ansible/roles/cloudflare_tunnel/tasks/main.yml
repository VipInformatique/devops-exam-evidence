---
- name: Create Cloudflare namespace
  kubernetes.core.k8s:
    kubeconfig: "{{ k3s_kubeconfig }}"
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: cloudflare
  ignore_errors: true  # ok if it already exists

# IMPORTANT: ensure the credentials Secret exists BEFORE deploying resources that mount it
- name: Create/Update cloudflared credentials Secret from local file
  kubernetes.core.k8s:
    kubeconfig: "{{ k3s_kubeconfig }}"
    namespace: cloudflare
    state: present
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: cloudflared-credentials
      type: Opaque
      data:
        # read file from controller and base64-encode; fails early if path is wrong
        credentials.json: "{{ lookup('file', cloudflared_credentials_path) | b64encode }}"
  when:
    - cloudflared_credentials_path is defined
    - cloudflared_credentials_path | length > 0
  register: secret_result

# Render your combined manifest (ConfigMap + Deployment, etc.)
- name: Render Cloudflared manifest
  template:
    src: cloudflared.yaml.j2
    dest: /tmp/cloudflared.yaml

# Apply rendered resources (idempotent)
- name: Deploy Cloudflared resources
  kubernetes.core.k8s:
    kubeconfig: "{{ k3s_kubeconfig }}"
    state: present
    src: /tmp/cloudflared.yaml
  register: deploy_result

- name: DEBUG replicas var
  debug:
    msg: "cloudflared_replicas={{ cloudflared_replicas | default('UNSET') }}"

- name: Ensure cloudflared replicas count
  kubernetes.core.k8s_scale:
    kubeconfig: "{{ k3s_kubeconfig }}"
    api_version: apps/v1
    kind: Deployment
    name: cloudflared
    namespace: cloudflare
    replicas: "{{ cloudflared_replicas | default(1) }}"

# Trigger a safe rolling restart ONLY when something actually changed
# (e.g., new credentials or updated manifest)
- name: Restart cloudflared only if needed
  when: secret_result.changed or deploy_result.changed
  kubernetes.core.k8s:
    kubeconfig: "{{ k3s_kubeconfig }}"
    state: patched
    definition:
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: cloudflared
        namespace: cloudflare
      spec:
        template:
          metadata:
            annotations:
              kubectl.kubernetes.io/restartedAt: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"

# Build DNS records list for Cloudflare API (unchanged logic)
- name: CLOUDFLARED | Build DNS records list to create
  ansible.builtin.set_fact:
    cloudflare_dns_records: "{{ (cloudflare_dns_records | default([])) + [dns_rec] }}"
  vars:
    _h: "{{ item.hostname }}"
    _sub: >-
      {% set zone = '.' + zone_name %}
      {{ _h[0:(_h|length - zone|length)] if _h.endswith(zone) else _h }}
    dns_rec:
      record: "{{ '@' if _h == zone_name else _sub }}"
      type: "CNAME"
      value: "{{ cloudflare_tunnel_id }}.cfargotunnel.com"
      proxied: true
  loop: "{{ cloudflared_tunnel_routes }}"
  delegate_to: localhost
  run_once: true

# Keep your existing metrics tasks as-is
- import_tasks: metrics.yml

# Ensure CNAME records exist in Cloudflare (unchanged behavior)
- name: "CLOUDFLARED | Ensure CNAME records exist in Cloudflare"
  community.general.cloudflare_dns:
    zone: "{{ zone_name }}"
    record: "{{ item.record }}"
    type: "{{ item.type }}"
    value: "{{ item.value }}"
    proxied: "{{ item.proxied }}"
    state: present
    api_token: "{{ cf_api_token }}"
  loop: "{{ cloudflare_dns_records }}"
  loop_control:
    label: "{{ item.record }}"
  delegate_to: localhost
  run_once: true
  ignore_errors: true
