---
# 1) Alertmanager Secret (Telegram)
- name: Ensure monitoring namespace exists
  kubernetes.core.k8s:
    state: present
    api_version: v1
    kind: Namespace
    name: "{{ monitoring_ns }}"
    kubeconfig: "{{ kubeconfig_path }}"
  tags: [alerting, secret]

- name: Create/Update Secret alertmanager-config (Telegram)
  kubernetes.core.k8s:
    state: present
    kubeconfig: "{{ kubeconfig_path }}"
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: "{{ alertmanager_secret_name }}"
        namespace: "{{ monitoring_ns }}"
      type: Opaque
      stringData:
        alertmanager.yaml: "{{ lookup('template', 'alertmanager-config.yaml.j2') }}"
  tags: [alerting, secret]

# 2) Operator accepted the config + restart + pods readiness
- name: Wait until Alertmanager CR is Reconciled=True
  kubernetes.core.k8s_info:
    api_version: monitoring.coreos.com/v1
    kind: Alertmanager
    name: "{{ kps_release }}-alertmanager"
    namespace: "{{ monitoring_ns }}"
    kubeconfig: "{{ kubeconfig_path }}"
  register: am_cr
  until: >
    (am_cr.resources | length > 0) and
    (
      (am_cr.resources[0].status.conditions | selectattr('type','equalto','Reconciled') | list | length) > 0 and
      ((am_cr.resources[0].status.conditions | selectattr('type','equalto','Reconciled') | first).status == 'True')
    )
  retries: 30
  delay: 5
  tags: [alerting, wire]

- name: Restart Alertmanager to reload config
  ansible.builtin.command: >
    kubectl -n {{ monitoring_ns }}
    rollout restart statefulset alertmanager-{{ kps_release }}-alertmanager
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  changed_when: true
  tags: [alerting, wire]

- name: Wait until Alertmanager pods are Ready
  ansible.builtin.command: >
    kubectl -n {{ monitoring_ns }}
    wait --for=condition=ready pod
    -l app.kubernetes.io/name=alertmanager,alertmanager={{ kps_release }}-alertmanager
    --timeout=300s
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  register: am_wait
  changed_when: false
  failed_when: am_wait.rc != 0
  tags: [alerting, wire]

# 3) Verify via API (reliable endpoint: alertmanager-operated)
- name: Get Alertmanager /api/v2/status via ephemeral curl pod
  ansible.builtin.command: >
    kubectl -n {{ monitoring_ns }}
    run amcheck --rm -i --restart=Never --image=curlimages/curl --
    curl -s --fail http://alertmanager-operated.{{ monitoring_ns }}.svc:9093/api/v2/status
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  register: am_status
  changed_when: false
  retries: 10
  delay: 3
  until: am_status.rc == 0
  failed_when: am_status.rc != 0
  tags: [alerting, verify]

- name: Assert that Alertmanager uses our receivers
  ansible.builtin.assert:
    that:
      - am_status.stdout is search('name: devistor-default')
      - am_status.stdout is search('name: devistor-ops')
      - am_status.stdout is search('name: devistor-critical')
    fail_msg: >
      Alertmanager nie używa naszego secreta albo nie przeładował configu.
      Sprawdź alertmanager.configSecret={{ alertmanager_secret_name }} i wykonaj rollout restart.
    success_msg: "OK: AM wczytał naszych receiverów (default/ops/critical)."
  tags: [alerting, verify]

# 4) Prometheus rules (first recordings, then alerts)
- name: Apply Devistor latency recording rules
  kubernetes.core.k8s:
    state: present
    kubeconfig: "{{ kubeconfig_path }}"
    definition: "{{ lookup('template', 'prometheusrule-latency.yaml.j2') | from_yaml }}"
  tags: [alerting, rules, latency]

- name: Apply Devistor alert rules
  kubernetes.core.k8s:
    state: present
    kubeconfig: "{{ kubeconfig_path }}"
    definition: "{{ lookup('template', 'prometheusrule-devistor.yaml.j2') | from_yaml }}"
  tags: [alerting, rules]
